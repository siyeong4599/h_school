<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
</head>
<h1>1_scope.html</h1>
<body>
    <script>
      // 자료 구조: 데이터와 데이터에 적용할 수 있는 함수나 명령의 모음
      // 배열, 리스트, 해시, 딕셔너리, 튜플, ...

      //
      // 1. array(배열): 데이터와 추가된 순서가 유지되고 중복을
      //                 허용하는 선형 자료구조 
      //

      // 배열의 생성
      const a1 = []; // 비어 있는 배열 생성
      console.log(a1);

      const a2 = [1,2,3,4]; // 값과 값을 구분하기 위해 쉼표를 사용해야 함
      //          ^... 원소 또는 요소: 자료구조 안의 값을 의미
      console.log(a2); // 추가된 순서가 유지

      const a3 = [1,1,1];
      console.log(a3); // 중복을 허용

      // 배열은 자바스크립트가 제공하는 모든 타입의 값을 저장할 수있습니다.
      const a4 = [10, 3.14, "hello", true, [1,2,3]];
      cosole.log(a4);

      // ----------------------------------------------------------------------------------------------------------
      // 인덱싱: 인덱스를 사용하여 원소를 참조하는 문법
      //           -8 -7 -6 -5 -4 -3 -2 -1 
      //            0  1  2  3  4  5  6  7 <- 인덱스(index)
      const arr = [11,22,33,44,55,66,77,88];

      // usage: 배열명[인덱스]
      console.log(arr[0]);
      console.log(arr[7]);

      // 배열의 원소를 얻어오는 방법
      console.log(arr.length);

      // 마지막 원소를 얻어오는 방법
      console.log(arr[arr.length-1]);
      console.log(arr.at(-1));// console.log(arr[-1]);

      // 주의! 존재하지 않는 원소에 대하여 인덱싱을 수행하면
      // undefined가 반환됩니다.

      // ----------------------------------------------------------------------------------------------------------------
      // 슬라이싱(slicing): 일부 연속된 구간을 선택하는 문법
      //          0  1  2  3  4  5  6  7
      const a = [11,22,33,44,55,66,77,88];

      // usage: 배열명.slice(시작인덱스, 끝인덱스); -> 시작값은 포함되나
      // 끝 값은 포함되지 않는 반개구간입니다.
      console.log(a.slice(1, 5));

      // 마지막 원소를 포함할 경우, 마지막 원소의 인덱스의
      // 큰 값을 넣어주시면 됩니다.
      console.log(a.slice(1, 8));
      console.log(a.slice(1, 10));

      // 배열 전체에 대하여 슬라이싱을 한다고 가정합니다.
      console.log(a.slic(0, 8));

      // 만약 마지막 원소가 포함된 경우라면, 마지막 인덱스를 생략할
      // 수 있습니다.
      console.log(a.slice(0));

      // 또한 시작 인덱스의 값이 0이면 이를 생략할 수 있습니다.
      console.log(a.slice());

      // 슬라이싱을 하면 새로운 배열이 반환됩니다.
      const b = a.slice();
      b[0] = 0;
      console.og(a); 

      // ---------------------------------------------------------------------------------------------------------------------
      // 배열의 순회
      //                 0         1         2         3
      const fruits = ["apple", "banana", "cherry", "durian"];

      // 1. 조건 기반의 for
      for (let idx = 0; idx < fruits.length; idx++) {
          console.log(fruits[idx]);
      }

        // 2. 원소 기반의 for
        for (const fname of fruits) {
          console.log(fname);
      }

      // 3. forEach
      function myfunc(item,     // 원소가 전달됩니다. 
                      idx,      // 원소의 인덱스가 전달됩니다.
                      array) {    // 배열이 전달됩니다.
        console.log(item);
      }
      fruits.forEach(myfunc);

      // 자바스크립트에서는 이름이 없는 함수를 만들 수 있습니다.
      // usage: functiong([매개변수[,..]]) {}
      fruits.forEach(function(item, idx, arr) {
          console.log(item);
      });

      // ---------------------------------------------------------------------------------------------------------------------------
      // 원소의 갱신(update)
      //const fruits = ["apple", "banana", "cherry", "durian"];
      console.log(fruits);

      // usage: 배열명[인덱스] = 값;
      fruits[0] = "사과";
      console.log(fruits);

      // ----------------------------------------------------------------------------------------------------------------------------
      // 원소의 추가 1. 배열의 추가
      fruits.push("포도");
      console.log(fruits);

      // 앞에서 추가하는 경우
      fruits.unshift("오렌지");
      console.log(fruits);

      // -------------------------------------------------------------------------------------------------------------------------------
      // 원소의 삭제: 배열의 끝에서 삭제
      let item = fruits.pop();
      console.log(item);
      console.log(fruits);

      // 배열의 앞에서 삭제
      item = fruits.shift();
      console.log(item);
      console.log(fruits);

      // -----------------------------------------------------------------------------------------------------------------------------------
      // 정렬
      const numbers = [1,3,5,7,9,2,4,6,8,10];
      console.log(numbers);

      // 양수일 때, 스왑됩니다.
      numbers.sort(function(a, b) {return a - b; }); // 오름차순    
      numbers.sort(function(a, b) {return b - a; }); // 내림차순
      console.log(numbers);























    </script>
</body>
</html>